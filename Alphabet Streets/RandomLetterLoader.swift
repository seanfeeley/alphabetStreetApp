//
//  RandomLetterLoader.swift
//  Alphabet Streets
//
//  Created by Sean Feeley on 03/11/2016.
//  Copyright Â© 2016 sean-feeley. All rights reserved.
//

import Foundation
import Parse
import ParseLiveQuery
import MapKit

class RandomLetterLoader {
    
    
    var points_to_upload: NSMutableArray = []
    var map: MKMapView!
    
    
    init(map: MKMapView) {
        
        self.map=map
        
  
//        let uploadPointsTimer = Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(ViewController.uploadAnnotations), userInfo: nil, repeats: true)
        //let movePointsTimer = Timer.scheduledTimer(timeInterval: 0.1, target: self, selector: #selector(ViewController.moveAnnotations), userInfo: nil, repeats: true)
        //let loadPointsTimer = Timer.scheduledTimer(timeInterval: 0.1, target: self, selector: #selector(ViewController.loadAnnotations), userInfo: nil, repeats: true)
        
        
    }

    
    
    func getAutoGeneratedLetters() -> [LetterAnnotation]{
        var letters:[LetterAnnotation]=[]
        let arraryOfCoords: NSMutableArray = self.getGridOfCoords()
        for coord in arraryOfCoords{
            let letterAnnotation:LetterAnnotation = LetterAnnotation(coord: coord as! CLLocationCoordinate2D)
            
            letters.append(letterAnnotation)
            
            
        }
        return letters
    }
    
    
    func getGridOfCoords() -> NSMutableArray{
        var coords:NSMutableArray=[]
        let topLeft: CLLocationCoordinate2D = self.getMapTopLeftCoordinate()
        
        let bottomRight: CLLocationCoordinate2D = self.getMapBottomRightCoordinate()
        
        
        
        var coord_to_add: CLLocationCoordinate2D = topLeft

        
        while coord_to_add.latitude > bottomRight.latitude{
            coord_to_add.longitude = topLeft.longitude
            coord_to_add.latitude = self.getNextUnEqualLatitude(coord: coord_to_add)
            
            while coord_to_add.longitude < bottomRight.longitude{
                coord_to_add.longitude = self.getNextUnEqualLongitude(coord: coord_to_add)
                
                if coord_to_add.latitude < topLeft.latitude && coord_to_add.longitude > topLeft.longitude{
                    
                    coords.add(coord_to_add)
                }
                
                
            }
            
        }
        
        return coords
    }
    func getNextUnEqualLatitude(coord: CLLocationCoordinate2D) -> CLLocationDegrees{
        let latitude: CLLocationDegrees = coord.latitude
        
        return latitude - CLLocationDegrees(LETTER_DENSITY)
    }
    func getNextUnEqualLongitude(coord: CLLocationCoordinate2D) -> CLLocationDegrees{
        let longitude: CLLocationDegrees = coord.longitude
        
        return longitude + CLLocationDegrees(LETTER_DENSITY)
    }
    
    
    func getNextEqualLatitude(coord: CLLocationCoordinate2D) -> CLLocationDegrees{
        var xyPoint: CGPoint = self.map.convert(coord, toPointTo: self.map.inputView)
        xyPoint.y = xyPoint.y + self.getLetterDensity()
        let newLocation = self.map.convert(xyPoint, toCoordinateFrom: self.map.inputView)
        return newLocation.latitude
    }
    func getNextEqualLongitude(coord: CLLocationCoordinate2D) -> CLLocationDegrees{
        var xyPoint: CGPoint = self.map.convert(coord, toPointTo: self.map.inputView)
        xyPoint.x = xyPoint.x + self.getLetterDensity()
        let newLocation = self.map.convert(xyPoint, toCoordinateFrom: self.map.inputView)
        return newLocation.longitude
    }
    func getLetterDensity() -> CGFloat
    {
        return LETTER_DENSITY / CGFloat(getZoomLevel(mapView: self.map))
    }
    
  
    
    func getMapTopLeftCoordinate() -> CLLocationCoordinate2D{
        let lat:CLLocationDegrees = CLLocationDegrees(round(RESOLUTION*(self.map.region.center.latitude + self.map.region.span.latitudeDelta))/RESOLUTION)
        let lon:CLLocationDegrees = CLLocationDegrees(round(RESOLUTION*(self.map.region.center.longitude - self.map.region.span.longitudeDelta))/RESOLUTION)
        let coord: CLLocationCoordinate2D = CLLocationCoordinate2D(latitude: lat, longitude: lon)
         
        return coord
    }
    func getMapBottomRightCoordinate() -> CLLocationCoordinate2D{
        let lat:CLLocationDegrees = CLLocationDegrees(round(RESOLUTION*(self.map.region.center.latitude - self.map.region.span.latitudeDelta))/RESOLUTION)
        let lon:CLLocationDegrees = CLLocationDegrees(round(RESOLUTION*(self.map.region.center.longitude + self.map.region.span.longitudeDelta))/RESOLUTION)
        let coord: CLLocationCoordinate2D = CLLocationCoordinate2D(latitude: lat, longitude: lon)
        return coord
    }
    
    
    func uploadAnnotations(){
        
        for object in self.points_to_upload{
            self.uploadAnnotation(obj: object as! Array<Any>)
            self.points_to_upload.remove(object)
            
        }
        
        
    }
    
    func uploadAnnotation(obj: Array<Any>){
        let query = PFQuery(className: "Active Letters")
        query.whereKey("objectId", equalTo: obj[0])
        query.findObjectsInBackground { (
            objects, error) in
            let prefObj = objects![0]
            prefObj["latitude"] = obj[1]
            prefObj["longitude"] = obj[2]
            prefObj.saveEventually()
        }
        
    }

    
    

    func areLettersStillVisible() -> Bool{
        let zoom_level = getZoomLevel(mapView: self.map)
       
    
        if(zoom_level <= ZOOM_CUT_OFF){
            return true
        }
        else{
            return false
        }
    }
    
    
    
    func addLetterToUploadQueue() {
        
    }
    
    
    func downloadLettersForArea() {
        
    }
    
    
    
    
}
